<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>10‑Second Video Recorder</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 24px; display: grid; place-items: center; min-height: 100vh; background: Canvas; color: CanvasText; }
    .card { width: min(720px, 92vw); border: 1px solid rgba(0,0,0,.1); border-radius: 18px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,.08); background: Field; }
    h1 { font-size: 1.25rem; margin: 0 0 12px; }
    p.note { margin: 8px 0 16px; font-size: .95rem; opacity: .8; }
    video { width: 100%; max-height: 60vh; background: #000; border-radius: 14px; }
    .controls { display: flex; gap: 10px; align-items: center; margin-top: 12px; flex-wrap: wrap; }
    button { padding: 10px 14px; border-radius: 12px; border: 0; font-weight: 600; cursor: pointer; background: #4f46e5; color: white; }
    button.secondary { background: #6b7280; }
    button.danger { background: #ef4444; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .status { font-variant-numeric: tabular-nums; font-weight: 600; }
    .spacer { flex: 1; }
    a.download { text-decoration: none; font-weight: 600; }
    .hidden { display: none; }
    .chip { display:inline-block; padding: 4px 8px; border-radius: 999px; background: color-mix(in srgb, CanvasText 12%, transparent); font-size: .8rem; }
  </style>
</head>
<body>
  <div class="card">
    <h1>10‑Second Video Recorder</h1>
    <p class="note">Click <b>Start 10s Recording</b>. The video will auto‑download when finished. If camera access fails from a local file, open this page via <span class="chip">http://localhost</span> (secure context is required by some browsers).</p>

    <video id="preview" playsinline autoplay muted></video>

    <div class="controls">
      <button id="startBtn">Start 10s Recording</button>
      <button id="stopBtn" class="danger" disabled>Stop now</button>
      <span class="spacer"></span>
      <span class="status" id="status">Idle</span>
      <a id="downloadLink" class="download hidden" href="#" download>Download</a>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const videoEl = document.getElementById('preview');
    const downloadLink = document.getElementById('downloadLink');

    let mediaStream;         // MediaStream from getUserMedia
    let mediaRecorder;       // MediaRecorder instance
    let chunks = [];         // Recorded Blob parts
    let stopTimer;           // Timer to auto‑stop after 10s

    async function ensureStream() {
      if (mediaStream && mediaStream.active) return mediaStream;
      // Ask for camera + mic. You can set audio:false to drop mic.
      mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      videoEl.srcObject = mediaStream;
      return mediaStream;
    }

    function pickMimeType() {
      const candidates = [
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus',
        'video/webm',
        'video/mp4;codecs=h264,aac' // Only some browsers
      ];
      for (const type of candidates) {
        if (MediaRecorder.isTypeSupported?.(type)) return type;
      }
      return '';
    }

    function resetRecorder() {
      chunks = [];
      clearTimeout(stopTimer);
      stopTimer = null;
      downloadLink.classList.add('hidden');
      downloadLink.removeAttribute('href');
    }

    startBtn.addEventListener('click', async () => {
      try {
        startBtn.disabled = true;
        resetRecorder();
        await ensureStream();

        const mimeType = pickMimeType();
        mediaRecorder = new MediaRecorder(mediaStream, mimeType ? { mimeType } : {});

        // Collect data as it becomes available
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };

        mediaRecorder.onstart = () => {
          statusEl.textContent = 'Recording… 10.0s';
          stopBtn.disabled = false;
          // Simple countdown
          let remaining = 10_000;
          const tick = () => {
            remaining -= 100;
            if (remaining >= 0 && mediaRecorder?.state === 'recording') {
              statusEl.textContent = `Recording… ${(remaining/1000).toFixed(1)}s`;
              setTimeout(tick, 100);
            }
          };
          setTimeout(tick, 100);
        };

        mediaRecorder.onstop = () => {
          stopBtn.disabled = true;
          startBtn.disabled = false;
          const blob = new Blob(chunks, { type: mediaRecorder.mimeType || 'video/webm' });
          const url = URL.createObjectURL(blob);
          const ts = new Date().toISOString().replaceAll(':', '-');
          const ext = (blob.type.includes('mp4') ? 'mp4' : 'webm');
          downloadLink.href = url;
          downloadLink.download = `recording-${ts}.${ext}`;
          downloadLink.classList.remove('hidden');
          // Auto‑trigger the download
          downloadLink.click();
          statusEl.textContent = 'Done. Saved to your downloads.';
        };

        mediaRecorder.start(100); // gather data every 100ms
        // Auto‑stop after 10 seconds
        stopTimer = setTimeout(() => {
          if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
        }, 10_000);
      } catch (err) {
        console.error(err);
        startBtn.disabled = false;
        statusEl.textContent = 'Error: ' + (err?.message || err);
        alert('Error starting camera/recorder: ' + (err?.message || err));
      }
    });

    stopBtn.addEventListener('click', () => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        clearTimeout(stopTimer);
      }
    });

    // Clean up when the page unloads
    window.addEventListener('beforeunload', () => {
      mediaRecorder?.state === 'recording' && mediaRecorder.stop();
      mediaStream?.getTracks().forEach(t => t.stop());
    });
  </script>
</body>
</html>
